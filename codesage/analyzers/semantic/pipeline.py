from typing import List

from codesage.analyzers.ast_models import FileAST
from codesage.analyzers.semantic.base_analyzer import AnalysisContext
from codesage.analyzers.semantic.complexity_analyzer import ComplexityAnalyzer
from codesage.analyzers.semantic.dependency_analyzer import DependencyAnalyzer
from codesage.analyzers.semantic.pattern_analyzer import PatternAnalyzer
from codesage.analyzers.semantic.models import AnalysisResult, DependencyGraph

class AnalysisPipeline:
    def __init__(self, context: AnalysisContext):
        self.context = context
        self.analyzers = [
            ComplexityAnalyzer(),
            DependencyAnalyzer(),
            PatternAnalyzer(),
        ]

    def run(self, file_ast: FileAST) -> AnalysisResult:
        complexity_metrics = self.analyzers[0].analyze(file_ast, self.context)
        # The dependency analyzer will be refactored to return just the imports
        imports = self.analyzers[1].analyze(file_ast, self.context)
        detected_patterns = self.analyzers[2].analyze(file_ast, self.context)

        # The dependency graph is built at the project level
        # For now, we'll create a dummy graph
        dependency_graph = DependencyGraph(
            nodes=[file_ast.path],
            edges=[],
            cycles=[],
            max_depth=0
        )

        return AnalysisResult(
            file_path=file_ast.path,
            complexity_metrics=complexity_metrics,
            dependencies=dependency_graph,
            detected_patterns=detected_patterns,
            issues=[] # Issues will be generated by the rules engine later
        )
